--------------------------------------------------------------------------------
-- Haskell bindings for the Tabula API                                        --
-- Copyright 2018 Michael B. Gale (m.gale@warwick.ac.uk)                      --
--------------------------------------------------------------------------------

module Warwick.Tabula (
    --module Warwick.Tabula.API,
    --module Warwick.Tabula.Internal,
    module Warwick.Tabula.Coursework,
    module Warwick.Tabula.Relationship,

    TabulaInstance(..),

    Tabula(..),

    ModuleCode(..),
    AssignmentID(..),

    TabulaResponse(..),
    TabulaAssignmentResponse(..),

    withTabula,

    listAssignments,
    retrieveAssignment,
    listSubmissions,

    TabulaDownloadCallbacks(..),
    downloadSubmission,
    downloadSubmissionWithCallbacks,

    retrieveMember,
    listRelationships,
    personAssignments
) where

--------------------------------------------------------------------------------

import Control.Monad.Catch (catch, throwM)
import Control.Monad.State
import Control.Monad.Except
--import Control.Monad.Throw

--import Data.Text
import qualified Data.ByteString as BS
import qualified Data.ByteString.Internal as BS
import Data.Text.Encoding (encodeUtf8)
import qualified Data.HashMap.Lazy as HM

import Data.Conduit
import Data.Conduit.Binary hiding (mapM_)

import Data.List (intercalate)

import Data.Aeson

import Network.HTTP.Conduit (newManager, tlsManagerSettings)
import Network.HTTP.Simple
import qualified Network.HTTP.Client.Conduit as C

import Servant.API.BasicAuth
import Servant.Client

import Warwick.Tabula.Config
import Warwick.Tabula.Types
import Warwick.Tabula.Error
import Warwick.Tabula.Coursework
import Warwick.Tabula.Member
import Warwick.Tabula.Relationship
import Warwick.Tabula.API
import qualified Warwick.Tabula.Internal as I

import Warwick.Tabula.TabulaSession
import Warwick.DownloadSubmission

-------------------------------------------------------------------------------

-- | Enumerates Tabula instances.
data TabulaInstance = Sandbox | Live | CustomInstance BaseUrl

-- | The URL to the Tabula API.
liveURL :: BaseUrl
liveURL = BaseUrl Https "tabula.warwick.ac.uk" 443 "/api/v1"

-- | The URL to the Tabula Sandbox API.
sandboxURL :: BaseUrl
sandboxURL = BaseUrl Https "tabula-sandbox.warwick.ac.uk" 443 "/api/v1"

-- | Determines the location of a given Tabula instance.
urlForInstance :: TabulaInstance -> BaseUrl
urlForInstance Sandbox              = sandboxURL
urlForInstance Live                 = liveURL
urlForInstance (CustomInstance url) = url

-------------------------------------------------------------------------------

-- | 'withTabula' @instance config action@ runs the computation @action@
-- by connecting to @instance@ with the configuration specified by @config@.
withTabula ::
    TabulaInstance -> TabulaConfig -> Tabula a -> IO (Either TabulaError a)
withTabula inst (TabulaConfig {..}) m = do
    manager <- newManager tlsManagerSettings

    let auth = BasicAuthData
                    (encodeUtf8 tabulaUsername)
                    (encodeUtf8 tabulaPassword)
        url  = urlForInstance inst
        env  = ClientEnv manager url
        sesh = TabulaSession auth manager url

    r <- runClientM (runExceptT $ evalStateT m sesh) (env Nothing)

    case r of
        Left serr -> return $ Left $ TransportError serr
        Right res -> return res

-------------------------------------------------------------------------------

-- | Client functions generated by servant throw exceptions when a server
-- returns a non-2xx status code. 'handle' @m@ catches exceptions which are
-- thrown when @m@ is executed and tries to convert them into a Tabula response.
handle :: (FromJSON a, HasPayload a)
       => ClientM (TabulaResponse a) -> Tabula (TabulaResponse a)
handle m = lift $ lift $ m `catch` \(e :: ServantError) -> case e of
   FailureResponse r -> case decode (responseBody r) of
       Nothing -> throwM e
       Just r  -> return r
   _                    -> throwM e

-------------------------------------------------------------------------------

listAssignments ::
    ModuleCode -> Maybe AcademicYear -> Tabula (TabulaResponse [Assignment])
listAssignments mc yr = do
    authData <- tabulaAuthData
    handle $ I.listAssignments authData mc yr

retrieveAssignment ::
    ModuleCode -> AssignmentID -> [String] -> Tabula (TabulaResponse Assignment)
retrieveAssignment mc aid xs = do
    let fdata = if Prelude.null xs then Nothing else Just (intercalate "," xs)
    authData <- tabulaAuthData
    handle $ I.retrieveAssignment authData mc (unAssignmentID aid) fdata

listSubmissions ::
    ModuleCode -> AssignmentID -> Tabula (TabulaResponse (HM.HashMap String (Maybe Submission)))
listSubmissions mc aid = do
    authData <- tabulaAuthData
    handle $ I.listSubmissions authData mc (unAssignmentID aid)

-------------------------------------------------------------------------------

retrieveMember :: String -> [String] -> Tabula (TabulaResponse Member)
retrieveMember uid fields = do
    let fdata = if Prelude.null fields then Nothing else Just (intercalate "," fields)
    authData <- tabulaAuthData
    handle $ I.retrieveMember authData uid fdata

listRelationships ::
    String -> Tabula (TabulaResponse [Relationship])
listRelationships uid = do
    authData <- tabulaAuthData
    handle $ I.listRelationships authData uid

personAssignments ::
    String -> Tabula TabulaAssignmentResponse
personAssignments uid = do
    authData <- tabulaAuthData
    lift $ lift $ I.personAssignments authData uid `catch` \(e :: ServantError) -> case e of
       FailureResponse r -> case decode (responseBody r) of
           Nothing -> throwM e
           Just r  -> return r
       _                    -> throwM e

-------------------------------------------------------------------------------
